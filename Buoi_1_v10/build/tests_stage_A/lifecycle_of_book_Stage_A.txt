✅ Dưới đây là sơ đồ RAM bằng text mô phỏng vòng đời của hàm create_book() khi bạn dùng Library library; và gọi hàm để tạo 1 sách mới.
Library library;
void create_book(int id, const char* title, const char* author) {
    Book* b = &library.books[book_count];
    b->id = id;
    strcpy(b->title, title);
    strcpy(b->author, author);
    b->is_deleted = false;
    add_event(EVENT_BOOK_CREATE, id, 0);
}

📊 SƠ ĐỒ RAM: Trong lúc create_book() đang chạy
+---------------------------+  ← Stack cao (gần địa chỉ lớn)
| Return address            | ← địa chỉ quay lại sau khi hàm kết thúc
| Previous frame pointer    |
|---------------------------|
| create_book() stack frame |
|---------------------------|
| id                        | ← (int) tham số
| title                     | ← (const char*) tham số → trỏ đến flash
| author                    | ← (const char*) tham số → trỏ đến flash
| b (Book*)                 | ← trỏ vào library.books[book_count]
+---------------------------+
| Các biến tạm khác         |
+---------------------------+  ← Stack thấp dần
        ...
        ...
+===========================+
| Global/static memory      |
|---------------------------|
| Library library;          | ← 5880 bytes RAM
|  - books[20]              |
|     - id                  |
|     - title[100]          |
|     - author[100]         |
|     - is_deleted          |
|  - users[10]              |
|  - transactions[20]       |
+---------------------------+
| Event timeline[100]       | ← ghi lại event BOOK_CREATE
+===========================+
        ...
+---------------------------+
| .data/.bss segment        |
| (biến toàn cục khác)      |
+---------------------------+
| Heap (nếu dùng malloc)    | ❌ Không dùng
+---------------------------+


✅ Sau khi create_book() kết thúc:
Stack frame của create_book() bị xóa

Dữ liệu sách vẫn còn trong library.books[]

Event vẫn còn trong timeline[]

🎯 Kết luận:
Bạn không mất dữ liệu, vì thông tin được sao chép vào vùng nhớ tĩnh

Không có vấn đề gì với stack trừ khi bạn tạo quá nhiều biến cục bộ lớn

Không cần heap nếu không dùng malloc


🎯 Tóm tắt
| Tình huống        | Dùng tốt ở đâu?                               |
| ----------------- | --------------------------------------------- |
| Dữ liệu tĩnh      | 🟢 STM32, nhúng nói chung                     |
| malloc + free     | 🟡 Trên PC, hoặc hệ thống lớn                 |
| malloc không free | 🔴 Gây rò rỉ bộ nhớ, rất nguy hiểm trên STM32 |


✅ Đúng rồi — các đối tượng như User, Transaction, Timeline, Library cũng nên theo mindset giống như Book:

Không nên dùng malloc()

Nên dùng mảng tĩnh đã khai báo sẵn trong Library

Tránh cấp phát động nếu không thực sự cần

Vòng đời và vị trí dữ liệu phải rõ ràng (dễ debug, tối ưu RAM)

👉 Đây là chiến lược tốt nhất cho STM32 hoặc bất kỳ hệ thống nhúng RAM thấp nào